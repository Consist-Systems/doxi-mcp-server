{
  "toolName": "FlowsTool",
  "category": "Flows",
  "description": "Manages document signing flows, templates, kits, users and webhooks via the Doxi Sign API.",
  "docsBaseUrl": "https://apidocs.doxi-sign.com/",
  "methods": [
    {
      "name": "GetAllFlows",
      "summary": "Retrieves all signing flows available for the current tenant.",
      "endpoint": "GET /flow",
      "returns": "JSON array of signing flow IDs and basic metadata (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password."
      }
    },
    {
      "name": "AddSignFlow",
      "summary": "Creates a new signing flow and uploads a document.",
      "endpoint": "POST /flow",
      "returns": "CreateFlowResponse JSON with SignFlowId and signer links (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "createFlowJsonRequest": "ExCreateFlowRequestBase JSON object describing the flow (SenderKey, Description, FlowElements, Users, Recipients, reminders, expiration, etc.).",
        "documentFile": "Document bytes for the flow (PDF/Word/Image). In MCP this is passed as a binary buffer and sent as multipart/form-data."
      }
    },
    {
      "name": "EditSignFlow",
      "summary": "Edits an existing signing flow (e.g. recipients, fields, metadata).",
      "endpoint": "POST /v2/flow/edit",
      "returns": "EditFlowResponse JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "EditFlowRequest JSON as defined in the OpenAPI (fields to modify in the existing flow)."
      }
    },
    {
      "name": "GetDocument",
      "summary": "Downloads the PDF document associated with a signing flow.",
      "endpoint": "GET /flow/{signFlowId}/Document",
      "returns": "PDF byte array as DataContent (contentType=\"application/pdf\").",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow.",
        "withSigns": "Boolean: if true, includes signatures/overlays; if false, returns the original document."
      }
    },
    {
      "name": "GetFlow",
      "summary": "Retrieves full metadata for a signing flow.",
      "endpoint": "GET /flow/{signFlowId}",
      "returns": "Flow metadata JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow."
      }
    },
    {
      "name": "SearchFlow",
      "summary": "Searches signing flows by filters such as signer, date range, status, custom fields, kit, etc.",
      "endpoint": "POST /ex/flow/search",
      "returns": "Search result JSON with matching flows (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "GetFlowsByFilterRequest JSON (SignatureFlowStatus, Signer, Sender, FromDate, ToDate, Description, KitId, CustomFields, etc.)."
      }
    },
    {
      "name": "GetFlowsStatus",
      "summary": "Retrieves statuses for multiple flows in a single call.",
      "endpoint": "POST /ex/flow/status",
      "returns": "Array of flow status responses (TextContent, JSON).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "GetFlowsStatusRequest JSON containing an array of SignFlowIds."
      }
    },
    {
      "name": "GetFlowStatus",
      "summary": "Gets the current status of a specific signing flow.",
      "endpoint": "GET /ex/flow/{signFlowId}/status",
      "returns": "GetFlowStatusResponse JSON (TextContent) including signers, sender, status, and custom fields.",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow."
      }
    },
    {
      "name": "SetFlowAction",
      "summary": "Sets an action on a flow such as approve, reject, delegate, etc.",
      "endpoint": "POST /flow/{signFlowId}/action",
      "returns": "JSON { success: true, data: { signFlowId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow.",
        "request": "SetFlowActionRequest JSON describing the action (e.g. approve, reject, comment, delegate)."
      }
    },
    {
      "name": "SetSignatures",
      "summary": "Updates or adds signatures to a flow.",
      "endpoint": "POST /flow/{signFlowId}/SetSignatures",
      "returns": "JSON { success: true, data: { signFlowId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow.",
        "request": "ExSetSignFlowRequest JSON including signature data for one or more signers."
      }
    },
    {
      "name": "ReplaceSigner",
      "summary": "Replaces an existing signer in a signing flow.",
      "endpoint": "POST /flow/ReplaceSigner",
      "returns": "JSON { success: true } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "ExReplaceSignerRequest JSON describing the original signer and the replacement signer."
      }
    },
    {
      "name": "GetFlowAttachments",
      "summary": "Gets all attachments of a flow as a ZIP archive.",
      "endpoint": "GET /flow/{signFlowId}/attachments",
      "returns": "ZIP byte array as DataContent (contentType=\"application/octet-stream\").",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow."
      }
    },
    {
      "name": "GetFlowAttachmentField",
      "summary": "Downloads a specific attachment field from a flow.",
      "endpoint": "POST /flow/{signFlowId}/AttachmentField",
      "returns": "Attachment bytes as DataContent (contentType=\"application/octet-stream\").",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow.",
        "request": "GetFlowAttachmentFieldRequest JSON (identifies the field/attachment to download)."
      }
    },
    {
      "name": "AddAttachmentAsBase64ToFlow",
      "summary": "Adds a base64-encoded attachment to an existing flow.",
      "endpoint": "POST /flow/{signFlowId}/attachments/base64",
      "returns": "AddAttachmentAsBase64ToFlowResponse JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow.",
        "request": "AddAttachmentBase64ToFlowRequest JSON containing base64 content, file name and optional metadata."
      }
    },
    {
      "name": "CreateFlowFromTemplate",
      "summary": "Creates a new signing flow from an existing template.",
      "endpoint": "POST /ex/template/CreateFlowFromTemplate/{templateId}",
      "returns": "CreateFlowResponse-like JSON with new SignFlowId and signer links (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "templateId": "The template ID to base the flow on.",
        "request": "CreateFlowFromTemplateRequest JSON (users, custom fields, description, etc.)."
      }
    },
    {
      "name": "AddTemplate",
      "summary": "Creates a new user template from a document and template definition.",
      "endpoint": "POST /ex/template",
      "returns": "Template creation result JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "addTemplateRequest": {
          "description": "AddTemplateRequest JSON. In MCP this contains: TemplateName, FlowElements, Users, SendMethodType, TemplateType, CaptchaDisabled, PreliminaryText, SignFlowDescriptionMessage, IsAutomaticRemainder, DayesForAutomaticRemainder, IsSendApprovalMailToAllSigners, Recipients, DisableSBS, FlowTwoFactorEnabled, FlowExpirationDate, ImagesList, SenderNotificationMailsToSend (from ExBaseTemplate), plus SenderKey (ParticipantKey<ParticipantKeyType>) and TemplateDocument (DataContent with Uri = original file name and Data = bytes). The server internally maps to ExAddTemplateRequest (DocumentFileName, Base64DocumentFile, SenderKey, TemplateName, etc.).",
          "typeRef": "#/types/AddTemplateRequest"
        }
      }
    },
    {
      "name": "UpdateTemplate",
      "summary": "Updates an existing template definition.",
      "endpoint": "PUT /ex/template/{templateId}",
      "returns": "JSON { success: true, data: { templateId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "templateId": "The ID of the template to update.",
        "request": "ExUpdateTemplateRequest JSON (TemplateName, FlowElements, Users, SendMethodType, TemplateType, CaptchaDisabled, PreliminaryText, SignFlowDescriptionMessage, IsAutomaticRemainder, DayesForAutomaticRemainder, IsSendApprovalMailToAllSigners, Recipients, DisableSBS, FlowTwoFactorEnabled, FlowExpirationDate, ImagesList)."
      }
    },
    {
      "name": "DeleteUserTemplate",
      "summary": "Deletes a user template.",
      "endpoint": "DELETE /ex/template/{templateId}",
      "returns": "JSON { success: true, data: { templateId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "templateId": "The ID of the template to delete.",
        "request": "DeleteTemplateRequest JSON (additional delete options if any)."
      }
    },
    {
      "name": "GetTemplate",
      "summary": "Retrieves template metadata.",
      "endpoint": "GET /ex/template/{templateId}",
      "returns": "Template metadata JSON (TextContent), including TemplateName, FlowElements, Users, SendMethodType, TemplateType, etc.",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "templateId": "The ID of the template."
      }
    },
    {
      "name": "DeleteAttachmentFromTemplate",
      "summary": "Deletes an attachment from a template.",
      "endpoint": "DELETE /ex/template/{templateId}/attachments/{attachmentId}",
      "returns": "JSON { success: true, data: { templateId, attachmentId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "templateId": "The template ID.",
        "attachmentId": "The attachment ID to remove from the template."
      }
    },
    {
      "name": "DocumentInfo",
      "summary": "Extracts structured information from a document file (e.g. pages, fields, text).",
      "endpoint": "POST /ex/document/info",
      "returns": "Document info JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "document": "Raw document bytes (PDF). In MCP this is provided as binary and sent as a file/stream body."
      }
    },
    {
      "name": "DocumentInfoBase64",
      "summary": "Extracts document info from a base64-encoded document.",
      "endpoint": "POST /ex/document/info/base64",
      "returns": "Document info JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "GetDocumentInfoRquest JSON (Base64DocumentFile, DocumentFileName, and optional settings)."
      }
    },
    {
      "name": "SearchInDocumentBase64",
      "summary": "Searches for text or patterns in a base64-encoded document.",
      "endpoint": "POST /ex/document/search/base64",
      "returns": "Search result JSON (TextContent) with matched locations.",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "SearchInDocumentBase64Request JSON containing Base64DocumentFile, search term(s), and options."
      }
    },
    {
      "name": "SearchInDocument",
      "summary": "Searches for text or patterns in an uploaded document.",
      "endpoint": "POST /ex/document/search",
      "returns": "Search result JSON (TextContent) with matched locations.",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "file": "Raw document bytes (PDF) to search in.",
        "request": "SearchInDocumentRequest JSON containing search term(s) and options."
      }
    },
    {
      "name": "MergeDocuments",
      "summary": "Merges multiple PDF documents into a single PDF.",
      "endpoint": "POST /ex/document/merge",
      "returns": "Merged PDF as DataContent (contentType=\"application/pdf\").",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "documents": "Array of PDF byte arrays to merge, in order."
      }
    },
    {
      "name": "AddKit",
      "summary": "Creates a new kit (a reusable bundle of flows or templates).",
      "endpoint": "POST /ex/kit",
      "returns": "Kit creation result JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "ExAddKitRequest JSON describing the kit (name, flows/templates, settings)."
      }
    },
    {
      "name": "UpdateKit",
      "summary": "Updates an existing kit.",
      "endpoint": "PUT /ex/kit/{kitId}",
      "returns": "JSON { success: true, data: { kitId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "kitId": "The ID of the kit to update.",
        "request": "ExUpdateKitRequest JSON with updated kit configuration."
      }
    },
    {
      "name": "GetKit",
      "summary": "Retrieves metadata for a kit.",
      "endpoint": "GET /ex/kit/{kitId}",
      "returns": "Kit metadata JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "kitId": "The ID of the kit."
      }
    },
    {
      "name": "GetKits",
      "summary": "Lists all kits available for the tenant.",
      "endpoint": "GET /ex/kit",
      "returns": "JSON array of kits (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password."
      }
    },
    {
      "name": "GetUserGroups",
      "summary": "Retrieves groups for a user identified by key type and value.",
      "endpoint": "GET /ex/user/{searchType}/{searchValue}/groups",
      "returns": "JSON array of groups (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "searchType": "ParticipantKeyType enum value (e.g. UserEmail, UserPhone).",
        "searchValue": "Search key for the user (e.g. email address or phone)."
      }
    },
    {
      "name": "GetUserTemplates",
      "summary": "Retrieves templates for a user identified by key type and value.",
      "endpoint": "GET /ex/user/{searchType}/{searchValue}/templates",
      "returns": "JSON array of templates (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "searchType": "ParticipantKeyType enum.",
        "searchValue": "Search key for the user (e.g. email address or phone)."
      }
    },
    {
      "name": "GetUserIdByEmail",
      "summary": "Retrieves user ID by email.",
      "endpoint": "GET /ex/user/byEmail/{email}/id",
      "returns": "JSON object with userId (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "email": "User email address."
      }
    },
    {
      "name": "GetUsers",
      "summary": "Queries users with filter parameters.",
      "endpoint": "GET /ex/users",
      "returns": "Paged results JSON of users (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "queryParams": "Dictionary<string, object> used as query parameters (e.g. page, pageSize, filters)."
      }
    },
    {
      "name": "AddSubscription",
      "summary": "Adds a webhook subscription for flow events.",
      "endpoint": "POST /ex/webhook",
      "returns": "WebhookSubscriptionResponse JSON with subscriptionId (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "WebhookSubscription JSON (callback URL, events, headers, filters, etc.)."
      }
    },
    {
      "name": "WebHookCheck",
      "summary": "Validates and previews a webhook payload for a given subscription definition.",
      "endpoint": "POST /ex/webhook/check",
      "returns": "Webhook preview JSON (TextContent) showing a sample payload.",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "WebhookSubscription JSON to validate."
      }
    },
    {
      "name": "GetAllWebhookSubscription",
      "summary": "Lists all webhook subscriptions for the tenant.",
      "endpoint": "GET /ex/webhook",
      "returns": "JSON array of webhook subscriptions (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password."
      }
    },
    {
      "name": "SearchWebhookCallLogs",
      "summary": "Searches webhook call logs for a specific subscription.",
      "endpoint": "POST /ex/webhook/{subscriptionId}/logs/search",
      "returns": "Paged logs JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "subscriptionId": "The webhook subscription ID.",
        "request": "RequestWebhookSenderLog JSON (date range, status filters, paging, etc.)."
      }
    },
    {
      "name": "UpdateWebhookSubscription",
      "summary": "Updates an existing webhook subscription.",
      "endpoint": "PUT /ex/webhook/{subscriptionId}",
      "returns": "JSON { success: true, data: { subscriptionId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "subscriptionId": "The webhook subscription ID.",
        "request": "WebhookSubscription JSON with updated configuration."
      }
    },
    {
      "name": "DeleteSubscription",
      "summary": "Deletes a webhook subscription.",
      "endpoint": "DELETE /ex/webhook/{subscriptionId}",
      "returns": "JSON { success: true, data: { subscriptionId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "subscriptionId": "The webhook subscription ID to delete."
      }
    }
  ],
  "enums": {
    "ParticipantKeyType": {
      "kind": "enum",
      "underlyingType": "integer",
      "values": [
        {
          "name": "UserId",
          "value": 0
        },
        {
          "name": "UserEmail",
          "value": 1
        },
        {
          "name": "UserPhone",
          "value": 2
        },
        {
          "name": "UserName",
          "value": 3
        },
        {
          "name": "GroupId",
          "value": 4
        }
      ]
    },
    "SendMethodType": {
      "kind": "enum",
      "underlyingType": "integer",
      "values": [
        {
          "name": "QueuedFlow",
          "value": 0
        },
        {
          "name": "ParallelFlow",
          "value": 1
        }
      ]
    },
    "TemplateType": {
      "kind": "enum",
      "underlyingType": "integer",
      "values": [
        {
          "name": "Standard",
          "value": 0
        },
        {
          "name": "AnonymousEnable",
          "value": 1
        },
        {
          "name": "AnonymousDisable",
          "value": 2
        },
        {
          "name": "Test",
          "value": 3
        }
      ]
    },
    "NotificationMails": {
      "kind": "enum",
      "underlyingType": "integer",
      "values": [
        {
          "name": "All",
          "value": 0
        },
        {
          "name": "None",
          "value": 1
        },
        {
          "name": "SignFlow",
          "value": 2
        },
        {
          "name": "FlowApproved",
          "value": 3
        },
        {
          "name": "FlowDeclined",
          "value": 4
        },
        {
          "name": "FlowStart",
          "value": 5
        },
        {
          "name": "ReminderToSignFlow",
          "value": 6
        },
        {
          "name": "FlowStoppedToSender",
          "value": 7
        },
        {
          "name": "FlowStoppedToSigner",
          "value": 8
        },
        {
          "name": "KitCompleted",
          "value": 9
        },
        {
          "name": "SignKit",
          "value": 10
        },
        {
          "name": "ReminderToSignKit",
          "value": 11
        },
        {
          "name": "KitCreated",
          "value": 12
        },
        {
          "name": "FlowExpired",
          "value": 13
        },
        {
          "name": "FlowCCApproved",
          "value": 14
        },
        {
          "name": "FlowCCDeclined",
          "value": 15
        }
      ]
    }
  },
  "types": {
    "DataContent": {
      "description": "Wrapper used by MCP to pass/receive binary files such as PDFs or ZIPs.",
      "type": "object",
      "properties": {
        "uri": {
          "type": "string",
          "description": "Logical file name, e.g. 'registration_tour_guide_avshalom.pdf'."
        },
        "contentType": {
          "type": "string",
          "description": "MIME type, e.g. 'application/pdf'."
        },
        "data": {
          "type": "string",
          "format": "binary",
          "description": "Raw file bytes. In MCP this is transmitted as binary, not base64."
        }
      },
      "required": [
        "uri",
        "data"
      ]
    },
    "ParticipantKey": {
      "description": "Identifies a Doxi user or group by key and type.",
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "Search value (e.g. email, phone, userId)."
        },
        "type": {
          "$ref": "#/enums/ParticipantKeyType",
          "description": "ParticipantKeyType numeric enum value."
        }
      },
      "required": [
        "key",
        "type"
      ]
    },
    "AddTemplateRequest": {
      "description": "High-level request used by the MCP AddTemplate tool. Wraps the template definition plus TemplateDocument as DataContent.",
      "type": "object",
      "properties": {
        "templateName": {
          "type": "string",
          "description": "Name of the template that will appear in Doxi UI."
        },
        "documentFileName": {
          "type": "string",
          "description": "File name of the template document (for logging/display)."
        },
        "senderKey": {
          "$ref": "#/types/ParticipantKey",
          "description": "Id of the sender (ParticipantKey<ParticipantKeyType>)."
        },
        "users": {
          "type": "array",
          "description": "Template users (ExTemplateUser[]).",
          "items": {
            "type": "object",
            "description": "Template user metadata (UserIndex, SignerType, NotificationMailsToSend, etc.)."
          }
        },
        "flowElements": {
          "type": "array",
          "description": "Template elements (fields and signatures). Each entry is based on ExTemplatFlowElement.",
          "items": {
            "type": "object",
            "description": "Element definition (ElementType, Position, IsRequired, etc.)."
          }
        },
        "sendMethodType": {
          "$ref": "#/enums/SendMethodType",
          "description": "Distribution method of the flow created from this template (numeric enum)."
        },
        "templateType": {
          "$ref": "#/enums/TemplateType",
          "description": "Template type (numeric enum)."
        },
        "captchaDisabled": {
          "type": "boolean",
          "description": "Disable/Enable captcha (only for anonymous templates)."
        },
        "preliminaryText": {
          "type": "string",
          "description": "Preliminary text of the flow created from this template."
        },
        "signFlowDescriptionMessage": {
          "type": "string",
          "description": "Description shown in email for the flow created from this template."
        },
        "isAutomaticRemainder": {
          "type": "boolean",
          "description": "Enable/Disable automatic reminder emails."
        },
        "dayesForAutomaticRemainder": {
          "type": "integer",
          "description": "Number of days between automatic reminders."
        },
        "isSendApprovalMailToAllSigners": {
          "type": "boolean",
          "description": "If true, all signers receive the approval mail."
        },
        "recipients": {
          "type": "array",
          "description": "All CC users of the flow created from this template.",
          "items": {
            "$ref": "#/types/ParticipantKey"
          }
        },
        "disableSBS": {
          "type": "boolean",
          "description": "Disable/Enable side-by-side mode in the created flow."
        },
        "flowTwoFactorEnabled": {
          "type": "boolean",
          "description": "Enable/Disable 2FA on flows created from this template."
        },
        "flowExpirationDate": {
          "type": "string",
          "format": "date-time",
          "description": "Expiration date of the flow created from this template."
        },
        "imagesList": {
          "type": "object",
          "description": "Dictionary of images for elements of type Image; key is image id (matches 'image-src' in AdditionalInfo), value is data URL.",
          "additionalProperties": {
            "type": "string",
            "nullable": true
          }
        },
        "senderNotificationMailsToSend": {
          "type": "array",
          "description": "NotificationMails enum values for sender notifications.",
          "items": {
            "$ref": "#/enums/NotificationMails"
          }
        },
        "templateDocument": {
          "$ref": "#/types/DataContent",
          "description": "PDF/Word/Image file the template is based on. In MCP this is represented as DataContent, not base64."
        }
      },
      "required": [
        "templateName",
        "senderKey",
        "templateDocument"
      ],
      "example": {
        "templateName": "Sample Template",
        "documentFileName": "someDoc.pdf",
        "senderKey": {
          "key": "someUser@someDomain.com",
          "type": 1
        },
        "users": [
          {
            "userIndex": 1,
            "title": "some signer job title",
            "fixedSignerKey": {
              "key": "someUser@someDomain.com",
              "type": 1
            },
            "signerType": 1,
            "isSuspended": true,
            "isNoDecline": true,
            "fixedUserEMail": "someUser@someDomain.com",
            "isChangable": false,
            "forceApprovalOnSignature": true,
            "notificationMailsToSend": [
              2,
              5
            ]
          }
        ],
        "flowElements": [],
        "sendMethodType": 0,
        "templateType": 0,
        "captchaDisabled": false,
        "isAutomaticRemainder": false,
        "dayesForAutomaticRemainder": 0,
        "isSendApprovalMailToAllSigners": false,
        "recipients": [],
        "disableSBS": false,
        "flowTwoFactorEnabled": false,
        "flowExpirationDate": null,
        "senderNotificationMailsToSend": [],
        "templateDocument": {
          "uri": "someDoc.pdf",
          "contentType": "application/pdf",
          "data": "<binary PDF data>"
        }
      }
    }
  }
}