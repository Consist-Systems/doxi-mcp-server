{
  "toolName": "FlowsTool",
  "category": "Flows",
  "description": "Manages document signing flows, templates, kits, users and webhooks via the Doxi Sign API.",
  "docsBaseUrl": "https://apidocs.doxi-sign.com/",
  "methods": [
    {
      "name": "GetAllFlows",
      "summary": "Retrieves all signing flows available for the current tenant.",
      "endpoint": "GET /flow",
      "returns": "JSON array of signing flow IDs and basic metadata (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password."
      }
    },
    {
      "name": "AddSignFlow",
      "summary": "Creates a new signing flow and uploads a document.",
      "endpoint": "POST /flow",
      "returns": "CreateFlowResponse JSON with SignFlowId and signer links (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "createFlowJsonRequest": "ExCreateFlowRequestBase JSON object describing the flow (SenderKey, Description, FlowElements, Users, Recipients, reminders, expiration, etc.).",
        "documentFile": "Document bytes for the flow (PDF/Word/Image). In MCP this is passed as a binary buffer and sent as multipart/form-data."
      }
    },
    {
      "name": "EditSignFlow",
      "summary": "Edits an existing signing flow (e.g. recipients, fields, metadata).",
      "endpoint": "POST /v2/flow/edit",
      "returns": "EditFlowResponse JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "EditFlowRequest JSON as defined in the OpenAPI (fields to modify in the existing flow)."
      }
    },
    {
      "name": "GetDocument",
      "summary": "Downloads the PDF document associated with a signing flow.",
      "endpoint": "GET /flow/{signFlowId}/Document",
      "returns": "PDF byte array as DataContent (contentType=\"application/pdf\").",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow.",
        "withSigns": "Boolean: if true, includes signatures/overlays; if false, returns the original document."
      }
    },
    {
      "name": "GetFlow",
      "summary": "Retrieves full metadata for a signing flow.",
      "endpoint": "GET /flow/{signFlowId}",
      "returns": "Flow metadata JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow."
      }
    },
    {
      "name": "SearchFlow",
      "summary": "Searches signing flows by filters such as signer, date range, status, custom fields, kit, etc.",
      "endpoint": "POST /ex/flow/search",
      "returns": "Search result JSON with matching flows (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "GetFlowsByFilterRequest JSON (SignatureFlowStatus, Signer, Sender, FromDate, ToDate, Description, KitId, CustomFields, etc.)."
      }
    },
    {
      "name": "GetFlowsStatus",
      "summary": "Retrieves statuses for multiple flows in a single call.",
      "endpoint": "POST /ex/flow/status",
      "returns": "Array of flow status responses (TextContent, JSON).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "GetFlowsStatusRequest JSON containing an array of SignFlowIds."
      }
    },
    {
      "name": "GetFlowStatus",
      "summary": "Gets the current status of a specific signing flow.",
      "endpoint": "GET /ex/flow/{signFlowId}/status",
      "returns": "GetFlowStatusResponse JSON (TextContent) including signers, sender, status, and custom fields.",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow."
      }
    },
    {
      "name": "SetFlowAction",
      "summary": "Sets an action on a flow such as approve, reject, delegate, etc.",
      "endpoint": "POST /flow/{signFlowId}/action",
      "returns": "JSON { success: true, data: { signFlowId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow.",
        "request": "SetFlowActionRequest JSON describing the action (e.g. approve, reject, comment, delegate)."
      }
    },
    {
      "name": "SetSignatures",
      "summary": "Updates or adds signatures to a flow.",
      "endpoint": "POST /flow/{signFlowId}/SetSignatures",
      "returns": "JSON { success: true, data: { signFlowId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow.",
        "request": "ExSetSignFlowRequest JSON including signature data for one or more signers."
      }
    },
    {
      "name": "ReplaceSigner",
      "summary": "Replaces an existing signer in a signing flow.",
      "endpoint": "POST /flow/ReplaceSigner",
      "returns": "JSON { success: true } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "ExReplaceSignerRequest JSON describing the original signer and the replacement signer."
      }
    },
    {
      "name": "GetFlowAttachments",
      "summary": "Gets all attachments of a flow as a ZIP archive.",
      "endpoint": "GET /flow/{signFlowId}/attachments",
      "returns": "ZIP byte array as DataContent (contentType=\"application/octet-stream\").",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow."
      }
    },
    {
      "name": "GetFlowAttachmentField",
      "summary": "Downloads a specific attachment field from a flow.",
      "endpoint": "POST /flow/{signFlowId}/AttachmentField",
      "returns": "Attachment bytes as DataContent (contentType=\"application/octet-stream\").",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow.",
        "request": "GetFlowAttachmentFieldRequest JSON (identifies the field/attachment to download)."
      }
    },
    {
      "name": "AddAttachmentAsBase64ToFlow",
      "summary": "Adds a base64-encoded attachment to an existing flow.",
      "endpoint": "POST /flow/{signFlowId}/attachments/base64",
      "returns": "AddAttachmentAsBase64ToFlowResponse JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "signFlowId": "The unique ID of the signing flow.",
        "request": "AddAttachmentBase64ToFlowRequest JSON containing base64 content, file name and optional metadata."
      }
    },
    {
      "name": "CreateFlowFromTemplate",
      "summary": "Creates a new signing flow from an existing template.",
      "endpoint": "POST /ex/template/CreateFlowFromTemplate/{templateId}",
      "returns": "CreateFlowResponse-like JSON with new SignFlowId and signer links (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "templateId": "The template ID to base the flow on.",
        "request": "CreateFlowFromTemplateRequest JSON (users, custom fields, description, etc.)."
      }
    },
    {
      "name": "AddTemplate",
      "summary": "Creates a new user template from a document and template definition.",
      "endpoint": "POST /ex/template",
      "returns": "Template creation result JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "addTemplateRequest": {
          "description": "AddTemplateRequest JSON. In MCP this contains: TemplateName, FlowElements, Users, SendMethodType, TemplateType, CaptchaDisabled, PreliminaryText, SignFlowDescriptionMessage, IsAutomaticRemainder, DayesForAutomaticRemainder, IsSendApprovalMailToAllSigners, Recipients, DisableSBS, FlowTwoFactorEnabled, FlowExpirationDate, ImagesList, SenderNotificationMailsToSend (from ExBaseTemplate), plus SenderKey (ParticipantKey<ParticipantKeyType>) and TemplateDocument (DataContent with Uri = original file name and Data = bytes). The server internally maps to ExAddTemplateRequest (DocumentFileName, Base64DocumentFile, SenderKey, TemplateName, etc.).",
          "typeRef": "#/types/AddTemplateRequest"
        }
      }
    },
    {
      "name": "UpdateTemplate",
      "summary": "Updates an existing template definition.",
      "endpoint": "PUT /ex/template/{templateId}",
      "returns": "JSON { success: true, data: { templateId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "templateId": "The ID of the template to update.",
        "request": "ExUpdateTemplateRequest JSON (TemplateName, FlowElements, Users, SendMethodType, TemplateType, CaptchaDisabled, PreliminaryText, SignFlowDescriptionMessage, IsAutomaticRemainder, DayesForAutomaticRemainder, IsSendApprovalMailToAllSigners, Recipients, DisableSBS, FlowTwoFactorEnabled, FlowExpirationDate, ImagesList)."
      }
    },
    {
      "name": "DeleteUserTemplate",
      "summary": "Deletes a user template.",
      "endpoint": "DELETE /ex/template/{templateId}",
      "returns": "JSON { success: true, data: { templateId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "templateId": "The ID of the template to delete.",
        "request": "DeleteTemplateRequest JSON (additional delete options if any)."
      }
    },
    {
      "name": "GetTemplate",
      "summary": "Retrieves template metadata.",
      "endpoint": "GET /ex/template/{templateId}",
      "returns": "Template metadata JSON (TextContent), including TemplateName, FlowElements, Users, SendMethodType, TemplateType, etc.",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "templateId": "The ID of the template."
      }
    },
    {
      "name": "DeleteAttachmentFromTemplate",
      "summary": "Deletes an attachment from a template.",
      "endpoint": "DELETE /ex/template/{templateId}/attachments/{attachmentId}",
      "returns": "JSON { success: true, data: { templateId, attachmentId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "templateId": "The template ID.",
        "attachmentId": "The attachment ID to remove from the template."
      }
    },
    {
      "name": "DocumentInfo",
      "summary": "Extracts structured information from a document file (e.g. pages, fields, text).",
      "endpoint": "POST /ex/document/info",
      "returns": "Document info JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "document": "Raw document bytes (PDF). In MCP this is provided as binary and sent as a file/stream body."
      }
    },
    {
      "name": "DocumentInfoBase64",
      "summary": "Extracts document info from a base64-encoded document.",
      "endpoint": "POST /ex/document/info/base64",
      "returns": "Document info JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "GetDocumentInfoRquest JSON (Base64DocumentFile, DocumentFileName, and optional settings)."
      }
    },
    {
      "name": "SearchInDocumentBase64",
      "summary": "Searches for text or patterns in a base64-encoded document.",
      "endpoint": "POST /ex/document/search/base64",
      "returns": "Search result JSON (TextContent) with matched locations.",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "SearchInDocumentBase64Request JSON containing Base64DocumentFile, search term(s), and options."
      }
    },
    {
      "name": "SearchInDocument",
      "summary": "Searches for text or patterns in an uploaded document.",
      "endpoint": "POST /ex/document/search",
      "returns": "Search result JSON (TextContent) with matched locations.",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "file": "Raw document bytes (PDF) to search in.",
        "request": "SearchInDocumentRequest JSON containing search term(s) and options."
      }
    },
    {
      "name": "MergeDocuments",
      "summary": "Merges multiple PDF documents into a single PDF.",
      "endpoint": "POST /ex/document/merge",
      "returns": "Merged PDF as DataContent (contentType=\"application/pdf\").",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "documents": "Array of PDF byte arrays to merge, in order."
      }
    },
    {
      "name": "AddKit",
      "summary": "Creates a new kit (a reusable bundle of flows or templates).",
      "endpoint": "POST /ex/kit",
      "returns": "Kit creation result JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "ExAddKitRequest JSON describing the kit (name, flows/templates, settings)."
      }
    },
    {
      "name": "UpdateKit",
      "summary": "Updates an existing kit.",
      "endpoint": "PUT /ex/kit/{kitId}",
      "returns": "JSON { success: true, data: { kitId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "kitId": "The ID of the kit to update.",
        "request": "ExUpdateKitRequest JSON with updated kit configuration."
      }
    },
    {
      "name": "GetKit",
      "summary": "Retrieves metadata for a kit.",
      "endpoint": "GET /ex/kit/{kitId}",
      "returns": "Kit metadata JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "kitId": "The ID of the kit."
      }
    },
    {
      "name": "GetKits",
      "summary": "Lists all kits available for the tenant.",
      "endpoint": "GET /ex/kit",
      "returns": "JSON array of kits (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password."
      }
    },
    {
      "name": "GetUserGroups",
      "summary": "Retrieves groups for a user identified by key type and value.",
      "endpoint": "GET /ex/user/{searchType}/{searchValue}/groups",
      "returns": "JSON array of groups (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "searchType": "ParticipantKeyType enum value (e.g. UserEmail, UserPhone).",
        "searchValue": "Search key for the user (e.g. email address or phone)."
      }
    },
    {
      "name": "GetUserTemplates",
      "summary": "Retrieves templates for a user identified by key type and value.",
      "endpoint": "GET /ex/user/{searchType}/{searchValue}/templates",
      "returns": "JSON array of templates (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "searchType": "ParticipantKeyType enum.",
        "searchValue": "Search key for the user (e.g. email address or phone)."
      }
    },
    {
      "name": "GetUserIdByEmail",
      "summary": "Retrieves user ID by email.",
      "endpoint": "GET /ex/user/byEmail/{email}/id",
      "returns": "JSON object with userId (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "email": "User email address."
      }
    },
    {
      "name": "GetUsers",
      "summary": "Queries users with filter parameters.",
      "endpoint": "GET /ex/users",
      "returns": "Paged results JSON of users (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "queryParams": "Dictionary<string, object> used as query parameters (e.g. page, pageSize, filters)."
      }
    },
    {
      "name": "AddSubscription",
      "summary": "Adds a webhook subscription for flow events.",
      "endpoint": "POST /ex/webhook",
      "returns": "WebhookSubscriptionResponse JSON with subscriptionId (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "WebhookSubscription JSON (callback URL, events, headers, filters, etc.)."
      }
    },
    {
      "name": "WebHookCheck",
      "summary": "Validates and previews a webhook payload for a given subscription definition.",
      "endpoint": "POST /ex/webhook/check",
      "returns": "Webhook preview JSON (TextContent) showing a sample payload.",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "request": "WebhookSubscription JSON to validate."
      }
    },
    {
      "name": "GetAllWebhookSubscription",
      "summary": "Lists all webhook subscriptions for the tenant.",
      "endpoint": "GET /ex/webhook",
      "returns": "JSON array of webhook subscriptions (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password."
      }
    },
    {
      "name": "SearchWebhookCallLogs",
      "summary": "Searches webhook call logs for a specific subscription.",
      "endpoint": "POST /ex/webhook/{subscriptionId}/logs/search",
      "returns": "Paged logs JSON (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "subscriptionId": "The webhook subscription ID.",
        "request": "RequestWebhookSenderLog JSON (date range, status filters, paging, etc.)."
      }
    },
    {
      "name": "UpdateWebhookSubscription",
      "summary": "Updates an existing webhook subscription.",
      "endpoint": "PUT /ex/webhook/{subscriptionId}",
      "returns": "JSON { success: true, data: { subscriptionId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "subscriptionId": "The webhook subscription ID.",
        "request": "WebhookSubscription JSON with updated configuration."
      }
    },
    {
      "name": "DeleteSubscription",
      "summary": "Deletes a webhook subscription.",
      "endpoint": "DELETE /ex/webhook/{subscriptionId}",
      "returns": "JSON { success: true, data: { subscriptionId } } (TextContent).",
      "params": {
        "username": "Doxi API username.",
        "password": "Doxi API password.",
        "subscriptionId": "The webhook subscription ID to delete."
      }
    }
  ],
  "enums": {
    "ParticipantKeyType": {
      "kind": "enum",
      "underlyingType": "integer",
      "values": [
        {
          "name": "UserId",
          "value": 0
        },
        {
          "name": "UserEmail",
          "value": 1
        },
        {
          "name": "UserPhone",
          "value": 2
        },
        {
          "name": "UserName",
          "value": 3
        },
        {
          "name": "GroupId",
          "value": 4
        }
      ]
    },
    "SendMethodType": {
      "kind": "enum",
      "underlyingType": "integer",
      "values": [
        {
          "name": "QueuedFlow",
          "value": 0
        },
        {
          "name": "ParallelFlow",
          "value": 1
        }
      ]
    },
    "TemplateType": {
      "kind": "enum",
      "underlyingType": "integer",
      "values": [
        {
          "name": "Standard",
          "value": 0
        },
        {
          "name": "AnonymousEnable",
          "value": 1
        },
        {
          "name": "AnonymousDisable",
          "value": 2
        },
        {
          "name": "Test",
          "value": 3
        }
      ]
    },
    "NotificationMails": {
      "kind": "enum",
      "underlyingType": "integer",
      "values": [
        {
          "name": "All",
          "value": 0
        },
        {
          "name": "None",
          "value": 1
        },
        {
          "name": "SignFlow",
          "value": 2
        },
        {
          "name": "FlowApproved",
          "value": 3
        },
        {
          "name": "FlowDeclined",
          "value": 4
        },
        {
          "name": "FlowStart",
          "value": 5
        },
        {
          "name": "ReminderToSignFlow",
          "value": 6
        },
        {
          "name": "FlowStoppedToSender",
          "value": 7
        },
        {
          "name": "FlowStoppedToSigner",
          "value": 8
        },
        {
          "name": "KitCompleted",
          "value": 9
        },
        {
          "name": "SignKit",
          "value": 10
        },
        {
          "name": "ReminderToSignKit",
          "value": 11
        },
        {
          "name": "KitCreated",
          "value": 12
        },
        {
          "name": "FlowExpired",
          "value": 13
        },
        {
          "name": "FlowCCApproved",
          "value": 14
        },
        {
          "name": "FlowCCDeclined",
          "value": 15
        }
      ]
    },
    "TemplateElementType": {
      "kind": "enum",
      "underlyingType": "integer",
      "values": [
        {
          "name": "Signature",
          "value": 0
        },
        {
          "name": "Text",
          "value": 1
        },
        {
          "name": "Checkbox",
          "value": 2
        },
        {
          "name": "Date",
          "value": 3
        },
        {
          "name": "AttachmentField",
          "value": 4
        },
        {
          "name": "Image",
          "value": 5
        },
        {
          "name": "ComboBox",
          "value": 6
        }
      ]
    }
  },
  "types": {
    "DataContent": {
      "description": "Wrapper used by MCP to pass/receive binary files such as PDFs or ZIPs.",
      "type": "object",
      "properties": {
        "uri": {
          "type": "string",
          "description": "Logical file name, e.g. 'registration_tour_guide_avshalom.pdf'."
        },
        "contentType": {
          "type": "string",
          "description": "MIME type, e.g. 'application/pdf'."
        },
        "data": {
          "type": "string",
          "format": "binary",
          "description": "Raw file bytes. In MCP this is transmitted as binary, not base64."
        }
      },
      "required": [
        "uri",
        "data"
      ]
    },
    "ParticipantKey": {
      "description": "Identifies a Doxi user or group by key and type.",
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "Search value (e.g. email, phone, userId)."
        },
        "type": {
          "$ref": "#/enums/ParticipantKeyType",
          "description": "ParticipantKeyType numeric enum value."
        }
      },
      "required": [
        "key",
        "type"
      ]
    },
    "AddTemplateRequest": {
      "description": "High-level request used by the MCP AddTemplate tool. Wraps the template definition plus TemplateDocument as DataContent.",
      "type": "object",
      "properties": {
        "templateName": {
          "type": "string",
          "description": "Name of the template that will appear in Doxi UI."
        },
        "documentFileName": {
          "type": "string",
          "description": "File name of the template document (for logging/display)."
        },
        "senderKey": {
          "$ref": "#/types/ParticipantKey",
          "description": "Id of the sender (ParticipantKey<ParticipantKeyType>)."
        },
        "users": {
          "type": "array",
          "description": "Template users (ExTemplateUser[]).",
          "items": {
            "type": "object",
            "description": "Template user metadata (UserIndex, SignerType, NotificationMailsToSend, etc.)."
          }
        },
        "flowElements": {
          "type": "array",
          "description": "Template elements (fields and signatures). Each entry is based on ExTemplatFlowElement.",
          "items": {
            "$ref": "#/types/ExTemplatFlowElement"
          }
        },
        "sendMethodType": {
          "$ref": "#/enums/SendMethodType",
          "description": "Distribution method of the flow created from this template (numeric enum)."
        },
        "templateType": {
          "$ref": "#/enums/TemplateType",
          "description": "Template type (numeric enum)."
        },
        "captchaDisabled": {
          "type": "boolean",
          "description": "Disable/Enable captcha (only for anonymous templates)."
        },
        "preliminaryText": {
          "type": "string",
          "description": "Preliminary text of the flow created from this template."
        },
        "signFlowDescriptionMessage": {
          "type": "string",
          "description": "Description shown in email for the flow created from this template."
        },
        "isAutomaticRemainder": {
          "type": "boolean",
          "description": "Enable/Disable automatic reminder emails."
        },
        "dayesForAutomaticRemainder": {
          "type": "integer",
          "description": "Number of days between automatic reminders."
        },
        "isSendApprovalMailToAllSigners": {
          "type": "boolean",
          "description": "If true, all signers receive the approval mail."
        },
        "recipients": {
          "type": "array",
          "description": "All CC users of the flow created from this template.",
          "items": {
            "$ref": "#/types/ParticipantKey"
          }
        },
        "disableSBS": {
          "type": "boolean",
          "description": "Disable/Enable side-by-side mode in the created flow."
        },
        "flowTwoFactorEnabled": {
          "type": "boolean",
          "description": "Enable/Disable 2FA on flows created from this template."
        },
        "flowExpirationDate": {
          "type": "string",
          "format": "date-time",
          "description": "Expiration date of the flow created from this template."
        },
        "imagesList": {
          "type": "object",
          "description": "Dictionary of images for elements of type Image; key is image id (matches 'image-src' in AdditionalInfo), value is data URL.",
          "additionalProperties": {
            "type": "string",
            "nullable": true
          }
        },
        "senderNotificationMailsToSend": {
          "type": "array",
          "description": "NotificationMails enum values for sender notifications.",
          "items": {
            "$ref": "#/enums/NotificationMails"
          }
        },
        "templateDocument": {
          "$ref": "#/types/DataContent",
          "description": "The original PDF file for the template. This parameter MUST be filled automatically using the user's uploaded file. If the user uploads a file in the chat, use it as DataContent { uri: <filename>, data: <binary> } without asking for approval.",
          "file": true
        }
      },
      "required": [
        "templateName",
        "senderKey",
        "templateDocument"
      ],
      "example": {
        "templateName": "Sample Template",
        "documentFileName": "someDoc.pdf",
        "senderKey": {
          "key": "someUser@someDomain.com",
          "type": 1
        },
        "users": [
          {
            "userIndex": 1,
            "title": "some signer job title",
            "fixedSignerKey": {
              "key": "someUser@someDomain.com",
              "type": 1
            },
            "signerType": 1,
            "isSuspended": true,
            "isNoDecline": true,
            "fixedUserEMail": "someUser@someDomain.com",
            "isChangable": false,
            "forceApprovalOnSignature": true,
            "notificationMailsToSend": [
              2,
              5
            ]
          }
        ],
        "flowElements": [],
        "sendMethodType": 0,
        "templateType": 0,
        "captchaDisabled": false,
        "isAutomaticRemainder": false,
        "dayesForAutomaticRemainder": 0,
        "isSendApprovalMailToAllSigners": false,
        "recipients": [],
        "disableSBS": false,
        "flowTwoFactorEnabled": false,
        "flowExpirationDate": null,
        "senderNotificationMailsToSend": [],
        "templateDocument": {
          "uri": "someDoc.pdf",
          "contentType": "application/pdf",
          "data": "<binary PDF data>"
        }
      }
    },
    "Validation": {
      "description": "Validation rule for a template element (mirrors Validation schema from the Doxi API).",
      "type": "object",
      "properties": {
        "regex": {
          "type": "string",
          "description": "Regular expression used to validate the field value.",
          "nullable": true
        },
        "errorCode": {
          "type": "integer",
          "description": "Numeric error code returned when validation fails.",
          "format": "int32"
        }
      }
    },
    "StringStringKeyValuePair": {
      "description": "Simple key/value pair of strings as defined in the Doxi API (StringStringKeyValuePair).",
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "nullable": true
        },
        "value": {
          "type": "string",
          "nullable": true
        }
      }
    },
    "ExTemplatFlowElement": {
      "description": "Template flow element definition used in AddTemplate and UpdateTemplate (fields and signatures placed on the document). Based on ExTemplatFlowElement from the Doxi API.",
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Element identifier inside the template.",
          "nullable": true
        },
        "name": {
          "type": "string",
          "description": "Optional logical name of the element.",
          "nullable": true
        },
        "elementType": {
          "$ref": "#/enums/TemplateElementType",
          "description": "Numeric enum indicating the type of element (signature, text, checkbox, date, etc.)."
        },
        "userIndex": {
          "type": "integer",
          "description": "Index of the user/signature this element belongs to.",
          "format": "int32"
        },
        "pageIndex": {
          "type": "integer",
          "description": "Zero-based page index on which the element is placed.",
          "format": "int32"
        },
        "x": {
          "type": "number",
          "description": "X position (in document units) of the element on the page."
        },
        "y": {
          "type": "number",
          "description": "Y position (in document units) of the element on the page."
        },
        "width": {
          "type": "number",
          "description": "Element width (in document units)."
        },
        "height": {
          "type": "number",
          "description": "Element height (in document units)."
        },
        "isRequired": {
          "type": "boolean",
          "description": "If true, the signer must fill/complete this element."
        },
        "groupId": {
          "type": "string",
          "description": "Optional group identifier for grouping related elements (e.g. radio buttons).",
          "nullable": true
        },
        "additionalInfo": {
          "type": "array",
          "description": "Additional element configuration as key/value pairs (depends on element type).",
          "items": {
            "$ref": "#/types/StringStringKeyValuePair"
          },
          "nullable": true
        },
        "validation": {
          "$ref": "#/types/Validation",
          "description": "Optional validation rule applied to the element value."
        }
      }
    },
    "ExCreateFlowRequestBase": {
      "description": "Request body for creating a signing flow (used by AddSignFlow). Mirrors the ExCreateFlowRequestBase model from the Doxi API.",
      "type": "object",
      "properties": {
        "senderKey": {
          "$ref": "#/types/ParticipantKey",
          "description": "Sender of the flow."
        },
        "description": {
          "type": "string",
          "description": "Human-readable description of the flow."
        },
        "users": {
          "type": "array",
          "description": "Signers/approvers participating in the flow (order, roles, notification options, etc.).",
          "items": {
            "type": "object",
            "description": "User definition (index, signer type, notification options, etc.)."
          }
        },
        "flowElements": {
          "type": "array",
          "description": "Fields and signature elements placed on the document.",
          "items": {
            "type": "object",
            "description": "Element definition including type, position, page, required flag, etc."
          }
        },
        "recipients": {
          "type": "array",
          "description": "CC recipients that receive notifications about the flow.",
          "items": {
            "$ref": "#/types/ParticipantKey"
          }
        },
        "expirationDate": {
          "type": "string",
          "format": "date-time",
          "description": "Date/time when the flow expires."
        },
        "customFields": {
          "type": "object",
          "description": "Optional custom metadata fields attached to the flow.",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "EditFlowRequest": {
      "description": "Request body used to edit an existing signing flow (EditSignFlow).",
      "type": "object",
      "properties": {
        "signFlowId": {
          "type": "string",
          "description": "ID of the flow to edit."
        },
        "description": {
          "type": "string",
          "description": "New description for the flow (optional)."
        },
        "users": {
          "type": "array",
          "description": "Updated users/signers configuration.",
          "items": {
            "type": "object"
          }
        },
        "flowElements": {
          "type": "array",
          "description": "Updated field/signature elements.",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "GetFlowsByFilterRequest": {
      "description": "Filter object for searching flows (SearchFlow).",
      "type": "object",
      "properties": {
        "signer": {
          "type": "string",
          "description": "Signer identifier (email / user id / phone, depending on configuration)."
        },
        "sender": {
          "type": "string",
          "description": "Sender identifier."
        },
        "fromDate": {
          "type": "string",
          "format": "date-time",
          "description": "Start of date range filter."
        },
        "toDate": {
          "type": "string",
          "format": "date-time",
          "description": "End of date range filter."
        },
        "description": {
          "type": "string",
          "description": "Free-text search on the flow description."
        },
        "kitId": {
          "type": "string",
          "description": "Filter flows that were created from a specific kit."
        },
        "customFields": {
          "type": "object",
          "description": "Key/value filters on custom fields.",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "GetFlowsStatusRequest": {
      "description": "Request body for GetFlowsStatus containing the list of flow IDs.",
      "type": "object",
      "properties": {
        "signFlowIds": {
          "type": "array",
          "description": "Array of flow IDs whose status should be retrieved.",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "signFlowIds"
      ]
    },
    "SetFlowActionRequest": {
      "description": "Request body describing an action to apply to a flow (SetFlowAction).",
      "type": "object",
      "properties": {
        "action": {
          "type": "string",
          "description": "Action to apply (e.g. approve, reject, delegate)."
        },
        "comment": {
          "type": "string",
          "description": "Optional comment for the action."
        },
        "delegateTo": {
          "type": "string",
          "description": "If action is delegate, identifier of the user to delegate to."
        }
      },
      "required": [
        "action"
      ]
    },
    "ExSetSignFlowRequest": {
      "description": "Request body used to update or add signatures to a flow (SetSignatures).",
      "type": "object",
      "properties": {
        "signFlowId": {
          "type": "string",
          "description": "ID of the flow (may be redundant with the path parameter)."
        },
        "signatures": {
          "type": "array",
          "description": "Collection of signature definitions to apply.",
          "items": {
            "type": "object",
            "description": "Individual signature definition (user index, element id, value, etc.)."
          }
        }
      }
    },
    "ExReplaceSignerRequest": {
      "description": "Request body telling the API to replace one signer with another (ReplaceSigner).",
      "type": "object",
      "properties": {
        "signFlowId": {
          "type": "string",
          "description": "ID of the flow whose signer should be replaced."
        },
        "originalSigner": {
          "type": "string",
          "description": "Identifier of the signer to replace."
        },
        "replacementSigner": {
          "type": "string",
          "description": "Identifier of the new signer."
        }
      }
    },
    "GetFlowAttachmentFieldRequest": {
      "description": "Request body for GetFlowAttachmentField which identifies a specific attachment field.",
      "type": "object",
      "properties": {
        "fieldId": {
          "type": "string",
          "description": "Identifier of the attachment field to download."
        }
      },
      "required": [
        "fieldId"
      ]
    },
    "AddAttachmentBase64ToFlowRequest": {
      "description": "Request body for adding an attachment encoded as base64 to an existing flow.",
      "type": "object",
      "properties": {
        "base64DocumentFile": {
          "type": "string",
          "description": "Base64 encoded file content."
        },
        "documentFileName": {
          "type": "string",
          "description": "File name of the attachment."
        },
        "contentType": {
          "type": "string",
          "description": "MIME type of the attachment."
        },
        "metadata": {
          "type": "object",
          "description": "Optional custom metadata to associate with the attachment.",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "required": [
        "base64DocumentFile",
        "documentFileName"
      ]
    },
    "CreateFlowFromTemplateRequest": {
      "description": "Request body for creating a new flow from an existing template.",
      "type": "object",
      "properties": {
        "users": {
          "type": "array",
          "description": "Users/signers participating in the created flow.",
          "items": {
            "type": "object"
          }
        },
        "recipients": {
          "type": "array",
          "description": "CC recipients for the created flow.",
          "items": {
            "$ref": "#/types/ParticipantKey"
          }
        },
        "description": {
          "type": "string",
          "description": "Description of the created flow."
        },
        "customFields": {
          "type": "object",
          "description": "Custom fields to populate in the flow.",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "ExUpdateTemplateRequest": {
      "description": "Request body used to update an existing template (UpdateTemplate). Structure is similar to AddTemplateRequest without TemplateDocument.",
      "type": "object",
      "properties": {
        "templateName": {
          "type": "string",
          "description": "New template name."
        },
        "users": {
          "type": "array",
          "description": "Updated template users.",
          "items": {
            "type": "object"
          }
        },
        "flowElements": {
          "type": "array",
          "description": "Updated template elements.",
          "items": {
            "type": "object"
          }
        },
        "sendMethodType": {
          "$ref": "#/enums/SendMethodType",
          "description": "Numeric enum indicating the send method."
        },
        "templateType": {
          "$ref": "#/enums/TemplateType",
          "description": "Numeric enum indicating the template type."
        }
      }
    },
    "DeleteTemplateRequest": {
      "description": "Additional options for deleting a template (DeleteUserTemplate).",
      "type": "object",
      "properties": {
        "deleteDocuments": {
          "type": "boolean",
          "description": "If true, associated documents are also deleted (if supported by API)."
        }
      }
    },
    "GetDocumentInfoRquest": {
      "description": "Request body for DocumentInfoBase64 (typo preserved to match API).",
      "type": "object",
      "properties": {
        "base64DocumentFile": {
          "type": "string",
          "description": "Base64 encoded document content."
        },
        "documentFileName": {
          "type": "string",
          "description": "Logical document file name."
        }
      },
      "required": [
        "base64DocumentFile",
        "documentFileName"
      ]
    },
    "SearchInDocumentBase64Request": {
      "description": "Request body for searching text or patterns in a base64-encoded document.",
      "type": "object",
      "properties": {
        "base64DocumentFile": {
          "type": "string",
          "description": "Base64 encoded document content."
        },
        "searchText": {
          "type": "string",
          "description": "Text or pattern to search for."
        }
      },
      "required": [
        "base64DocumentFile",
        "searchText"
      ]
    },
    "SearchInDocumentRequest": {
      "description": "Options used when searching in an uploaded document (SearchInDocument).",
      "type": "object",
      "properties": {
        "searchText": {
          "type": "string",
          "description": "Text or pattern to search for."
        }
      },
      "required": [
        "searchText"
      ]
    },
    "ExAddKitRequest": {
      "description": "Request body for creating a new kit (AddKit).",
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Kit name."
        },
        "description": {
          "type": "string",
          "description": "Optional description of what the kit contains."
        },
        "flows": {
          "type": "array",
          "description": "Definitions of flows/templates included in the kit.",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "ExUpdateKitRequest": {
      "description": "Request body for updating an existing kit (UpdateKit).",
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Updated kit name."
        },
        "description": {
          "type": "string",
          "description": "Updated kit description."
        },
        "flows": {
          "type": "array",
          "description": "Updated kit flows/templates configuration.",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "WebhookSubscription": {
      "description": "Webhook subscription definition used by AddSubscription, WebHookCheck and UpdateWebhookSubscription.",
      "type": "object",
      "properties": {
        "callbackUrl": {
          "type": "string",
          "description": "HTTPS endpoint that will receive webhook calls."
        },
        "events": {
          "type": "array",
          "description": "List of event types (as strings) that should trigger the webhook.",
          "items": {
            "type": "string"
          }
        },
        "headers": {
          "type": "object",
          "description": "Optional HTTP headers to send with each webhook call.",
          "additionalProperties": {
            "type": "string"
          }
        },
        "secret": {
          "type": "string",
          "description": "Optional secret used to sign webhook payloads."
        },
        "filters": {
          "type": "object",
          "description": "Optional filters that limit which flows trigger the webhook.",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "RequestWebhookSenderLog": {
      "description": "Search criteria for webhook call logs (SearchWebhookCallLogs).",
      "type": "object",
      "properties": {
        "fromDate": {
          "type": "string",
          "format": "date-time",
          "description": "Start of the log search date range."
        },
        "toDate": {
          "type": "string",
          "format": "date-time",
          "description": "End of the log search date range."
        },
        "status": {
          "type": "string",
          "description": "Optional delivery status filter (e.g. Success, Failed)."
        },
        "page": {
          "type": "integer",
          "description": "Page index for paging."
        },
        "pageSize": {
          "type": "integer",
          "description": "Number of items per page."
        }
      }
    }
  }
}